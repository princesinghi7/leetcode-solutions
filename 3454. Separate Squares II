class Solution {
public:
    struct Event {
        double y, x1, x2;
        int type;
        bool operator<(const Event& other) const {
            return y < other.y;
        }
    };

    double separateSquares(vector<vector<int>>& squares) {
        vector<Event> events;
        for (auto &s : squares) {
            double x = s[0], y = s[1], l = s[2];
            events.push_back({y, x, x + l, 1});
            events.push_back({y + l, x, x + l, -1});
        }

        sort(events.begin(), events.end());
        multiset<pair<double,double>> active;

        auto calcWidth = [&]() {
            if (active.empty()) return 0.0;
            vector<pair<double,double>> v(active.begin(), active.end());
            sort(v.begin(), v.end());
            double res = 0, L = v[0].first, R = v[0].second;
            for (int i = 1; i < v.size(); i++) {
                if (v[i].first > R) {
                    res += R - L;
                    L = v[i].first;
                    R = v[i].second;
                } else R = max(R, v[i].second);
            }
            res += R - L;
            return res;
        };

        double total = 0, prevY = events[0].y;
        int i = 0;

        while (i < events.size()) {
            double y = events[i].y;
            double w = calcWidth();
            total += w * (y - prevY);

            while (i < events.size() && events[i].y == y) {
                if (events[i].type == 1)
                    active.insert({events[i].x1, events[i].x2});
                else
                    active.erase(active.find({events[i].x1, events[i].x2}));
                i++;
            }
            prevY = y;
        }

        double need = total / 2.0;
        active.clear();
        prevY = events[0].y;
        i = 0;
        double cur = 0;

        while (i < events.size()) {
            double y = events[i].y;
            double w = calcWidth();
            double area = w * (y - prevY);

            if (cur + area >= need)
                return prevY + (need - cur) / w;

            cur += area;

            while (i < events.size() && events[i].y == y) {
                if (events[i].type == 1)
                    active.insert({events[i].x1, events[i].x2});
                else
                    active.erase(active.find({events[i].x1, events[i].x2}));
                i++;
            }
            prevY = y;
        }
        return prevY;
    }
};
